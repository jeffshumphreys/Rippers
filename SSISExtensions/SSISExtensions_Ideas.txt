            MyEventListener eventListener = new MyEventListener();

            XmlDocument SSISPackageAsXMLDoc = new XmlDocument();
            SSISPackageAsXMLDoc.PreserveWhitespace = true;
            //XmlNamespaceManager nsmanager = new XmlNamespaceManager(SSISPackageAsXMLDoc.NameTable);
            //nsmanager.AddNamespace("DTS", "www.microsoft.com/SqlServer/Dts");
            //nsmanager.PushScope();
            SSISPackageAsXMLDoc.Load(fullPathToPackage);
            //XmlElement root = SSISPackageAsXMLDoc.DocumentElement;
            //var basenode = root.SelectSingleNode(@"/DTS:Executable", nsmanager);
            //bool? DelayValidation = basenode.Attributes["DTS:DelayValidation"]?.Value?.ToBool();

            //if (DelayValidation != true)
            //{
            //    var DelayValidationAttribute = SSISPackageAsXMLDoc.CreateAttribute("DTS:DelayValidation");
            //    DelayValidationAttribute.Value = "True";
            //    basenode.Attributes.SetNamedItem(DelayValidationAttribute);
            //}

            //bool? OfflineMode = basenode.Attributes["DTS:OfflineMode"]?.Value?.ToBool();
            //if (OfflineMode != true)
            //{
            //    var OfflineModeAttribute = SSISPackageAsXMLDoc.CreateAttribute("DTS:OfflineMode");
            //    OfflineModeAttribute.Value = "True";
            //    basenode.Attributes.SetNamedItem(OfflineModeAttribute);
            //}

            //var connectionnodes = root.SelectNodes(@"/DTS:Executable/DTS:ConnectionManagers/DTS:ConnectionManager", nsmanager);
            //foreach (XmlNode connectionnode in connectionnodes)
            //{
            //    bool? ConnectionManagerDelayValidation = connectionnode.Attributes["DTS:DelayValidation"]?.Value?.ToBool();

            //    if (ConnectionManagerDelayValidation != true)
            //    {
            //        var ConnectionManagerDelayValidationAttribute = SSISPackageAsXMLDoc.CreateAttribute("DTS:DelayValidation");
            //        ConnectionManagerDelayValidationAttribute.Value = "True";
            //        connectionnode.Attributes.SetNamedItem(ConnectionManagerDelayValidationAttribute);
            //    }

            //    bool? ConnectionManagerOfflineMode = connectionnode.Attributes["DTS:OfflineMode"]?.Value?.ToBool();
            //    if (OfflineMode != true)
            //    {
            //        var ConnectionManagerOfflineModeAttribute = SSISPackageAsXMLDoc.CreateAttribute("DTS:OfflineMode");
            //        ConnectionManagerOfflineModeAttribute.Value = "True";
            //        connectionnode.Attributes.SetNamedItem(ConnectionManagerOfflineModeAttribute);
            //    }
            //}
            Project temporaryInMemSSISProject = Project.CreateProject();

            // Only way to load a project in offline mode programmatically is to do these machinations.
            temporaryInMemSSISProject.OfflineMode = true;
            temporaryInMemSSISProject.PackageItems.Add(package, "tempPackageInMemory.dtsx");
            package.LoadFromXML(SSISPackageAsXMLDoc.OuterXml, eventListener);  // 266 ms for 120KB
            // TaskHost taskH = (TaskHost)p.Executables.Add(typeof(Microsoft.SqlServer.Dts.Tasks.ScriptTask.ScriptTask).AssemblyQualifiedName);  
            //           if (taskH.ExecutionResult == DTSExecResult.Failure || taskH.ExecutionStatus == DTSExecStatus.Abend)  
            //// Slow load if no OfflineMode embedded.

			//temporaryInMemSSISProject.VersionBuild
            //temporaryInMemSSISProject.VersionComments
            //temporaryInMemSSISProject.VersionMajor
            //temporaryInMemSSISProject.VersionMinor
            var projectFormatVersion = temporaryInMemSSISProject.FormatVersion;
            //temporaryInMemSSISProject.Parameters
            //temporaryInMemSSISProject.Password
            //temporaryInMemSSISProject.ProtectionLevel
            //temporaryInMemSSISProject.Site
            //temporaryInMemSSISProject.PackageItems
            //temporaryInMemSSISProject.ConnectionManagerItems

			SQL Version	Build #	PackageFormatVersion	Visual Studio Version
			2005	9		2   	2005
			2008	10		3   	2008
			2008 R2	10.5	3   	2008
			2012	11		6   	2010 or BI 2012
			2014	12		8   	2012 CTP2 or 2013
			2016	13		8   	2015/2017
			2017	14		8   	2017

#if DTS130
    [DtsPipelineComponent(CurrentVersion = 3, DisplayName = "JSON Source Component", Description = "Downloads and parses a JSON file from the web.", ComponentType = ComponentType.Transform, UITypeName = "com.webkingsoft.JSONSource_Common.JSONSourceComponentUI,com.webkingsoft.JSONSource_130,Version=1.1.000.0,Culture=neutral", IconResource = "com.webkingsoft.JSONSource_130.jsource.ico")]
#elif DTS120
    [DtsPipelineComponent(CurrentVersion = 3, DisplayName = "JSON Source Component", Description = "Downloads and parses a JSON file from the web.", ComponentType = ComponentType.Transform, UITypeName = "com.webkingsoft.JSONSource_Common.JSONSourceComponentUI,com.webkingsoft.JSONSource_120,Version=1.1.000.0,Culture=neutral", IconResource = "com.webkingsoft.JSONSource_120.jsource.ico")]
#elif DTS110
    [DtsPipelineComponent(CurrentVersion = 3, DisplayName = "JSON Source Component", Description = "Downloads and parses a JSON file from the web.", ComponentType = ComponentType.Transform, UITypeName = "com.webkingsoft.JSONSource_Common.JSONSourceComponentUI,com.webkingsoft.JSONSource_110,Version=1.1.000.0,Culture=neutral", IconResource = "com.webkingsoft.JSONSource_110.jsource.ico")]
#endif

        /// Remember the lifecycle!
        /// AcquireConnections()
        /// Validate()
        /// ReleaseConnections()
        /// PrepareForExecute()
        /// AcquireConnections()
        /// PreExecute()
        /// PrimeOutput()
        /// ProcessInput()
        /// PostExecute()
        /// ReleaseConnections()
        /// Cleanup()

        private ParamBinding _uriBindingType;
        private PipelineBuffer _outputbuffer = null;
        private PipelineBuffer _errorbuffer = null;
        private IDTSInput100 _parametersInputLane;
        private IOMapEntry[] _iomap;
        private DateParseHandling _dateParsePolicy = DateParseHandling.DateTime;
        private ParallelOptions _opt;
        private OperationMode _mode;

        public override void PerformUpgrade(int pipelineVersion)
        {
            AttachDebugger();

            DataType type;
            try
            {
                var value = Utils.GetVariable(VariableDispenser, "WK_DEBUG", out type);
                MessageBox.Show("Attach the debugger now! PID: " + System.Diagnostics.Process.GetCurrentProcess().Id);
            }
            catch (Exception e)
            {
                // Do nothing
            }
            
            // Obtain the current component version from the attribute.
            DtsPipelineComponentAttribute componentAttribute = (DtsPipelineComponentAttribute)Attribute.GetCustomAttribute(this.GetType(), typeof(DtsPipelineComponentAttribute), false);
            int binaryVersion = componentAttribute.CurrentVersion;
            int metaDataVersion = ComponentMetaData.Version;

            // Upgrade the metadata if needed.
            if (metaDataVersion < binaryVersion)
            {
                // Upgrade step by step every version so we are able to align to the latest.
                if (metaDataVersion == 0) // No verison to 1.1.000.XX
                {
                    // From 0 to 1 we added ParseDates value with TRUE as default.
                    // By design, we don't need to do anything thanks to the default value handling
                }

                if (metaDataVersion == 1) {
                    // In this version we changed some properties. So we need to align to the new ones.
                    var m = ComponentMetaData.CustomPropertyCollection[ComponentConstants.PROPERTY_KEY_MODEL].Value.ToString();
                    dynamic previous = JsonConvert.DeserializeObject(m);

                    JSONSourceComponentModel current = new JSONSourceComponentModel();

                    // We updated the portion of the model regarding the data source and added some advanced features. 
                    // Let's handle data-source first: we introduced UriBindingType and UriBindingValue instead of SourceUri and FromVariable.
                    JSONDataSourceModel sourceModel = new JSONDataSourceModel();

                    // We added the URIBinding type parameter. This is based on the previous combination of FromVariable.
                    if ((bool)previous.DataSource.FromVariable)
                    {
                        sourceModel.UriBindingType = ParamBinding.Variable;
                        sourceModel.UriBindingValue = (string)previous.DataSource.VariableName;
                    }
                    else {
                        sourceModel.UriBindingType = ParamBinding.CustomValue;
                        sourceModel.UriBindingValue = (string)previous.DataSource.SourceUri.ToString();
                    }

                    // The rest just remains the same
                    sourceModel.CookieVariable = (string)previous.DataSource.CookieVariable;
                    List<HTTPParameter> headers = new List<HTTPParameter>();

                    if (previous.DataSource.HttpHeaders!= null)
                        foreach (var param in previous.DataSource.HttpHeaders)
                        {
                            headers.Add((HTTPParameter)param);
                        }
                    sourceModel.HttpHeaders = headers;

                    List<HTTPParameter> parameters = new List<HTTPParameter>();
                    if (previous.DataSource.HttpParameters != null)
                        foreach (var param in previous.DataSource.HttpParameters)
                        {
                            parameters.Add((HTTPParameter)param);
                        }
                    sourceModel.HttpParameters = parameters;

                    sourceModel.WebMethod = (string)previous.DataSource.WebMethod;

                    // Save the modified portion of the model
                    current.DataSource = sourceModel;

                    // Let's Handle upgrade the Advanced feature part of the model
                    current.AdvancedSettings = JSONAdvancedSettingsModel.LoadFromJson(previous.AdvancedSettings.ToString());
                    current.AdvancedSettings.NetworkErrorPolicy = ComponentConstants.NewDefaultNetworkHandlingPolicy();
                    current.AdvancedSettings.HttpErrorPolicy = ComponentConstants.NewDefaultHttpHandlingPolicy();

                    // Now just copy remaining sub-model
                    current.DataMapping = JSONDataMappingModel.LoadFromJson(previous.DataMapping.ToString());
                    

                    // Now just overwrite the saved model
                    ComponentMetaData.CustomPropertyCollection[ComponentConstants.PROPERTY_KEY_MODEL].Value = current.ToJsonConfig();
                    
                }

                if (metaDataVersion == 2)
                {
                    // We added support for Error Outputs
                    var e = ComponentMetaData.OutputCollection.GetEnumerator();
                    bool found = false;
                    while (e.MoveNext()) {
                        if ((e.Current as IDTSOutput100).Name == ComponentConstants.NAME_OUTPUT_ERROR_LANE) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        // Add it.
                        var i = ComponentMetaData.OutputCollection.New();
                        i.Name = ComponentConstants.NAME_OUTPUT_ERROR_LANE;
                        i.IsErrorOut = true;
                        
                        // Error output columns will contain some generic information about the errors that occurred during the execution, plus any input/request/filepath associated to that source
                        // -> ERROR_TYPE: can be "application", "parsing", "http", "generic"
                        // -> ERROR_DETAILS: contain some details regarding the error
                        // -> HTTP Code: used only if the error regards HTTP
                        
                        IDTSOutputColumn100 err_type = i.OutputColumnCollection.New();
                        err_type.SetDataTypeProperties(DataType.DT_WSTR, 50, 0, 0, 0);
                        err_type.Name = ComponentConstants.NAME_OUTPUT_ERROR_LANE_ERROR_TYPE;

                        IDTSOutputColumn100 err_details = i.OutputColumnCollection.New();
                        err_details.SetDataTypeProperties(DataType.DT_WSTR, 4000, 0, 0, 0);
                        err_details.Name = ComponentConstants.NAME_OUTPUT_ERROR_LANE_ERROR_DETAILS;

                        IDTSOutputColumn100 err_http_code = i.OutputColumnCollection.New();
                        err_http_code.SetDataTypeProperties(DataType.DT_UI4, 0, 0, 0, 0);
                        err_http_code.Name = ComponentConstants.NAME_OUTPUT_ERROR_LANE_ERROR_HTTP_CODE;

                    }

                }

                // At the end align the versions.
                ComponentMetaData.Version = binaryVersion;
            }

            // Forgot to upgrade the transformation on a server?
            if (metaDataVersion > binaryVersion)
            {
                throw new Exception("Runtime version of the component is out of date."
                + " Upgrading the installation can possibly solve this issue.");
            }
        }

        public override void ProvideComponentProperties()
        {
            // Clear all inputs and custom props, plus setup outputs
            base.RemoveAllInputsOutputsAndCustomProperties();
            var output = ComponentMetaData.OutputCollection.New();
            output.Name = "Parsed Json lines";

            // Set the output as asynchronous. This will allow us to use a single buffer between input and output.
            output.SynchronousInputID = 0;

            // Prepare the input lane for possible httpparams
            var params_lane = ComponentMetaData.InputCollection.New();
            params_lane.Name = ComponentConstants.NAME_INPUT_LANE_PARAMS;

            // Prepare error output column
            IDTSOutput100 errorOutput = ComponentMetaData.OutputCollection.New();
            errorOutput.IsErrorOut = true;
            errorOutput.Name = ComponentConstants.NAME_OUTPUT_ERROR_LANE;
            // The error lane is also asynchronous.
            errorOutput.SynchronousInputID = 0;

            IDTSOutputColumn100 err_type = errorOutput.OutputColumnCollection.New();
            err_type.SetDataTypeProperties(DataType.DT_WSTR, 50, 0, 0, 0);
            err_type.Name = ComponentConstants.NAME_OUTPUT_ERROR_LANE_ERROR_TYPE;

            IDTSOutputColumn100 err_details = errorOutput.OutputColumnCollection.New();
            err_details.SetDataTypeProperties(DataType.DT_WSTR, 4000, 0, 0, 0);
            err_details.Name = ComponentConstants.NAME_OUTPUT_ERROR_LANE_ERROR_DETAILS;

            IDTSOutputColumn100 err_http_code = errorOutput.OutputColumnCollection.New();
            err_http_code.SetDataTypeProperties(DataType.DT_UI4, 0, 0, 0, 0);
            err_http_code.Name = ComponentConstants.NAME_OUTPUT_ERROR_LANE_ERROR_HTTP_CODE;

            // TODO: initialize here custom properties for the model. It would be clearer and follows the MS Specs.
        }

        /// <summary>
        /// This method is invoked multiple times at design time. It is in charge of metadata checks. If some metadata is missing
        /// or inconsistent, Warnings and Errors will be thrown, so the user can fix them and the IDE will refuse running with bad metadata.
        /// </summary>
        /// <returns></returns>
        public override Microsoft.SqlServer.Dts.Pipeline.Wrapper.DTSValidationStatus Validate()
        {
            bool fireAgain = false;
            // basic component validation
            // - We only support up to 1 input lane
            // - We only support only one output line
            if (ComponentMetaData.InputCollection.Count > 1)
            {
                ComponentMetaData.FireError(ComponentConstants.ERROR_NO_INPUT_SUPPORTED, ComponentMetaData.Name, "This component only supports one input lane, for parameters.", null, 0, out fireAgain);
                return Microsoft.SqlServer.Dts.Pipeline.Wrapper.DTSValidationStatus.VS_ISBROKEN;
            }
            if (ComponentMetaData.OutputCollection.Count != 2)
            {
                ComponentMetaData.FireError(ComponentConstants.ERROR_SINGLE_OUTPUT_SUPPORTED, ComponentMetaData.Name, "This component only supports two output lanes: one for data and another for errors.", null, 0, out fireAgain);
                return Microsoft.SqlServer.Dts.Pipeline.Wrapper.DTSValidationStatus.VS_ISBROKEN;
            }

            // The rest of the validation process is provided by the MODEL object itself
            JSONSourceComponentModel m = null;
            try
            {
                m = GetModel();
            }
            catch (Exception e)
            {
                return Microsoft.SqlServer.Dts.Pipeline.Wrapper.DTSValidationStatus.VS_ISBROKEN;
            }

            // Validation is left to the model object
            string err = null;
            string warn = null;

            m.Validate(out err, out warn);

            if (!string.IsNullOrEmpty(warn)) {
                // Fire the warning, but do not return any invalid state
                // Fire the error and return an invalid state
                bool cancel;
                ComponentMetaData.FireWarning(ComponentConstants.RUNTIME_ERROR_MODEL_INVALID, ComponentMetaData.Name, err, null, 0);
                return Microsoft.SqlServer.Dts.Pipeline.Wrapper.DTSValidationStatus.VS_ISBROKEN;
            }

            if (!string.IsNullOrEmpty(err))
            {
                // Fire the error and return an invalid state
                bool cancel;
                ComponentMetaData.FireError(ComponentConstants.RUNTIME_ERROR_MODEL_INVALID, ComponentMetaData.Name, err, null, 0, out cancel);
                return Microsoft.SqlServer.Dts.Pipeline.Wrapper.DTSValidationStatus.VS_ISBROKEN;
            }

            // Although model is consistent, we must make sure the input columns it is refferring to are connected end existing.
            // Possible references to inputs are:
            // HTTP Params
            // CopyColumns
            foreach (var param in m.DataSource.HttpParameters) {
                if (param.Binding==ParamBinding.InputField)
                {
                    bool found = false;
                    foreach (IDTSInputColumn100 inputcol in ComponentMetaData.InputCollection[ComponentConstants.NAME_INPUT_LANE_PARAMS].InputColumnCollection) {
                        if (inputcol.Name == param.BindingValue) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        bool cancel;
                        // This column is not mapped. This will cause an error
                        ComponentMetaData.FireError(ComponentConstants.RUNTIME_ERROR_MODEL_INVALID, String.Format("HTTP parameter {0} requires input column {1} to be defined/connected. However there is no {1} column input attached.",param.Name,param.BindingValue), err, null, 0, out cancel);
                        return Microsoft.SqlServer.Dts.Pipeline.Wrapper.DTSValidationStatus.VS_ISBROKEN;
                    }
                }
            }

            // Also make sure copy columns are available
            foreach (var colname in m.DataMapping.InputColumnsToCopy) {
                bool found = false;
                foreach (IDTSInputColumn100 inputcol in ComponentMetaData.InputCollection[ComponentConstants.NAME_INPUT_LANE_PARAMS].InputColumnCollection)
                {
                    if (inputcol.Name == colname)
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    // This column is not mapped. This will cause an error
                    bool cancel;
                    ComponentMetaData.FireError(ComponentConstants.RUNTIME_ERROR_MODEL_INVALID, String.Format("However there is no {0} column input attached. Please update the component configuration.", colname), err, null, 0, out cancel);
                    return Microsoft.SqlServer.Dts.Pipeline.Wrapper.DTSValidationStatus.VS_ISBROKEN;
                }
            }

            // Everything seems ok.
            return Microsoft.SqlServer.Dts.Pipeline.Wrapper.DTSValidationStatus.VS_ISVALID;
        }

                        int colIndex = BufferManager.FindColumnByLineageID(ComponentMetaData.OutputCollection[0].Buffer, col.LineageID);
                        _outColsMaps.Add(e.OutputColName, colIndex);

                int input_index = BufferManager.FindColumnByLineageID(ComponentMetaData.InputCollection[ComponentConstants.NAME_INPUT_LANE_PARAMS].Buffer, ComponentMetaData.InputCollection[ComponentConstants.NAME_INPUT_LANE_PARAMS].InputColumnCollection[inputColName].LineageID);
                int output_index = BufferManager.FindColumnByLineageID(ComponentMetaData.OutputCollection[0].Buffer, ComponentMetaData.OutputCollection[0].OutputColumnCollection[inputColName].LineageID);

            _mode = ComponentMetaData.InputCollection[ComponentConstants.NAME_INPUT_LANE_PARAMS].IsAttached ? OperationMode.TRANSFORM : OperationMode.SOURCE;

                    int colIndex = BufferManager.FindColumnByLineageID(_parametersInputLane.Buffer, _parametersInputLane.GetVirtualInput().VirtualInputColumnCollection[value].LineageID);
                    //int colIndex = BufferManager.FindColumnByLineageID(_parametersInputLane.Buffer, _parametersInputLane.InputColumnCollection[value].LineageID);
                    uri = new Uri(inputBuffer[colIndex].ToString());


var value = Utils.GetVariable(VariableDispenser, "WK_DEBUG", out type);

        /// <summary>
        /// From MS Documentation:
        /// The PrimeOutput method is called when a component has at least one output, attached to a downstream component through an IDTSPath100 object, and the SynchronousInputID property of the output is zero. 
        /// The PrimeOutput method is called for source components and for transformations with asynchronous outputs. 
        /// Unlike the ProcessInput method described below, the PrimeOutput method is only called once for each component that requires it.
        /// </summary>
        /// <param name="outputs">Numbers of outputIDs provided</param>
        /// <param name="outputIDs">IDs of outputs</param>
        /// <param name="buffers">Buffers associated to outputs</param>
        public override void PrimeOutput(int outputs, int[] outputIDs, PipelineBuffer[] buffers)
        {
            // In case of SOURCE mode, we need to handle all the work here. Otherwise, in TRANSFORMATION mode, we just have to save a pointer
            // to the outputbuffer and do the work in ProcessInput.

            // Lookup buffers. We espect one error lane and one output lane. Indexes have been pre-calculated within PRE-EXECUTE
            for (int i=0;i<outputs;i++) {
                if (outputIDs[i] == _error_lane_output_id) {
                    _errorbuffer = buffers[i];
                } else {
                    // We simply assume that if the lane is not for error, then it regards output.
                    _outputbuffer = buffers[i];
                }
            }

            if (_mode == OperationMode.SOURCE)
            {
                // The following while loop is used to retry connection in case of errors. We brake when we
                // reach maximum error limit.
                bool done = false;
                while (!done)
                {
                    try
                    {
                        // For every input row, bind the parameters
                        Uri uri = ResolveUri(_uriBindingType, _uriBindingValue);

                        // Perform the request with appropriate inputs as HTTP params. In this case, we don't need to pass any input buffer,
                        // because there will be no input lane.
                        var headers = ResolveParametersBinding(_unboundHttpHeaders);
                        var parameters = ResolveParametersBinding(_unboundHttpParams);

                        bool downloaded;
                        bool cancel = false;

                        // So we are clear to proceed with the HTTP request.
                        ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Component is running in SOURCE MODE.", null, 0, ref cancel);
                        string fname = GetFileFromUri(uri, parameters, headers, out downloaded);

                        ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, String.Format("Temp json downloaded to {0}. Parsing json now...", fname), null, 0, ref cancel);

                        // Process data according to IOMappings
                        using (StreamReader sr = new StreamReader(File.Open(fname, FileMode.Open)))
                            ProcessInMemory(sr, _dataRootType, null, _outputbuffer);

                        ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Json parsed correctly.", null, 0, ref cancel);
                        
                        // TODO: UI option to prevent removal of downloaded data?
                        if (downloaded)
                        {
                            ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, String.Format("Removing downloaded json file {0}.", fname), null, 0, ref cancel);
                            File.Delete(fname);
                        }

                        // We were successful. The following statement will break the loop.
                        done = true;
                    }
                    catch (DataCollectionException e)
                    {
                        // TODO: Fire warning.
                        ComponentMetaData.FireWarning(ComponentConstants.RUNTIME_GENERIC_ERROR, ComponentMetaData.Name, String.Format("An error occurred during json gathering. This might be a consequence of a variety of reasons, including network problems. Error was: {0}. Details: {1}",e.Message,e.StackTrace), null, 0);

                        if (_errorbuffer != null)
                        {
                            _errorbuffer.AddRow();
                            // First two places reagard Error code and column index. We cannot mark any specific cause of the problem, so just put 0-0 here.
                            _errorbuffer[0] = 0;
                            _errorbuffer[1] = 0;
                            _errorbuffer[2] = "DATA_COLLECTION";
                            // Truncate error message if too long
                            _errorbuffer[3] = e.Message.Length > 4000 ? e.Message.Substring(0, 4000) : e.Message;
                            _errorbuffer[4] = null;  // No http response, so far.
                        }

                        if (!_networkErrorHandling.ShouldContinue())
                        {
                            ComponentMetaData.FireWarning(ComponentConstants.RUNTIME_GENERIC_ERROR, ComponentMetaData.Name, "Maximum number of failures reached. Aborting the execution.", null, 0);
                            break;
                        }
                        else
                        {
                            ComponentMetaData.FireWarning(ComponentConstants.RUNTIME_GENERIC_ERROR, ComponentMetaData.Name, String.Format("According to ErrorPolicy we should try again. Not aborting (yet), instead sleeping {0} seconds.", _networkErrorHandling.SleepTimeInSeconds), null, 0);
                            Thread.Sleep(_networkErrorHandling.SleepTimeInSeconds);
                        }
                    }
                    catch(BadHttpCodeException e)
                    {
                        // TODO: Fire warning.
                        ComponentMetaData.FireWarning(ComponentConstants.RUNTIME_GENERIC_ERROR, ComponentMetaData.Name, String.Format("The http response provided by the server wasn't successful. Error was: {0}. Details: {1}", e.Message, e.StackTrace), null, 0);
                        int code = e.GetResponseCode();

                        if (_errorbuffer != null)
                        {
                            _errorbuffer.AddRow();
                            // First two places reagard Error code and column index. We cannot mark any specific cause of the problem, so just put 0-0 here.
                            _errorbuffer[0] = 0;
                            _errorbuffer[1] = 0;
                            _errorbuffer[2] = "HTTP_BAD_RESPONSE_CODE";
                            // Truncate error message if too long
                            _errorbuffer[3] = e.Message.Length > 4095 ? e.Message.Substring(0, 4095) : e.Message;

                            // Check if the user has provided any specific error handling regarding this code, otherwise apply same strategy of datagathering error.
                            _errorbuffer[4] = code;
                        }

                        ErrorHandlingPolicy p = _networkErrorHandling;
                        if (_httpErrorPolicies.ContainsKey(code)) {
                            bool cancel = false;
                            ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Found HTTP error handling policy for error code "+code, null, 0, ref cancel);
                            p = _httpErrorPolicies[code];
                        }

                        if (!p.ShouldContinue())
                        {
                            ComponentMetaData.FireWarning(ComponentConstants.RUNTIME_GENERIC_ERROR, ComponentMetaData.Name, "Maximum number of failures reached. Aborting the execution.", null, 0);
                            break;
                        }
                        else
                        {
                            ComponentMetaData.FireWarning(ComponentConstants.RUNTIME_GENERIC_ERROR, ComponentMetaData.Name, String.Format("According to ErrorPolicy we should try again. Not aborting (yet), instead sleeping {0} seconds.", p.SleepTimeInSeconds), null, 0);
                            Thread.Sleep(p.SleepTimeInSeconds);
                        }
                    }
                    // We intentionally avoid to catch any other exception, such as bad json parsing and so on. Those errors must case failure of entire component,
                    // which is normal when the user fails to correctly parse json.
                }

                // Close output lane
                _outputbuffer.SetEndOfRowset();

                // Close the error lane.
                if (_errorbuffer!=null)
                    _errorbuffer.SetEndOfRowset();

            }
            else {
                bool cancel = false;
                ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Component is running in TRANSFORMATION MODE.", null, 0, ref cancel);
            }
        }

        /// <summary>
        /// This function takes care of retrieving the file data to be parsed. It alo handles retries.
        /// </summary>
        /// <param name="downloaded">True if the file was downloaded, false otherwise.</param>
        /// <returns>The path of the file to parse</returns>
        private string GetFileFromUri(Uri uri, Dictionary<string,string> parameters, Dictionary<string,string> headers, out bool downloaded)
        {
            // TODO: retry attempts.
            if (uri.IsFile)
            {
                downloaded = false;
                return uri.LocalPath;
            }
            else
            {
                CookieContainer cookies = new CookieContainer();
                downloaded = true;
                if (!String.IsNullOrEmpty(_cookieVarname))
                {
                    DataType type;
                    cookies = Utils.GetVariable(VariableDispenser, _cookieVarname, out type) as CookieContainer;
                }

                string computed_uri; ;
                var res = Utils.DownloadJson(this.VariableDispenser, uri, _httpMethod, parameters, headers, cookies, out computed_uri);

                bool cancel = false;
                ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, String.Format("Executed request {0}", computed_uri.ToString()), null, 0, ref cancel);

                // If the cookie container parameter was not null, assign the container to the variable
                if (!String.IsNullOrEmpty(_cookieVarname))
                {
                    IDTSVariables100 vars = null;
                    try
                    {
                        VariableDispenser.LockOneForWrite(_cookieVarname, ref vars);
                        vars[_cookieVarname].Value = cookies;
                    }
                    finally
                    {
                        if (vars != null)
                            vars.Unlock();
                    }

                }

                return res;
            }
        }

        private PipelineBuffer AddOutputRow(PipelineBuffer inputbuffer) {
            // Add A row and pre-fill it
            _outputbuffer.AddRow();

            if (inputbuffer != null)
                foreach (var input_output in _inputCopyToOutputMaps)
                {
                    _outputbuffer[input_output.Value] = inputbuffer[input_output.Key];
                }

            return _outputbuffer;
        }

        public override void ProcessInput(int inputID, PipelineBuffer inputbuffer)
        {
            // This method is invoked only when we are in TRANSFORMATION MODE, i.e. we have input-dependant parameters to handle. 
            // Thus, in here we need to BIND parameters to respective inputs, perform the HTTP request and parse data.
            // Note: since we only support one input lane, we assume inputID/inputbuffers are always referring to that input lane.
            
            // This method is invoked only when the component has some inputs to process. Otherwise, if no input has been specified, the PrimeOutput will handle all the job.
            bool cancel = false;
            ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Processing inputs...", null, 0, ref cancel);
            try
            {
                bool downloaded;
                ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Detected input lane attached. Executing in BATCH mode.", null, 0, ref cancel);
                while (inputbuffer.NextRow())
                {
                    // For every input row, bind the parameters
                    Uri uri = ResolveUri(_uriBindingType, _uriBindingValue, inputbuffer);

                    // Perform the request with appropriate inputs as HTTP params...
                    var headers = ResolveParametersBinding(_unboundHttpHeaders, inputbuffer);
                    var parameters = ResolveParametersBinding(_unboundHttpParams, inputbuffer);

                    // TODO FireInfo so that we log each request...
                    string fname = GetFileFromUri(uri, parameters, headers, out downloaded);
                    
                    // Process data according to IOMappings
                    using (StreamReader sr = new StreamReader(File.Open(fname, FileMode.Open)))
                        ProcessInMemory(sr, _dataRootType, inputbuffer, _outputbuffer);

                    if (downloaded)
                        File.Delete(fname);

                    ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Json parsed correctly.", null, 0, ref cancel);
                }
                
                if (inputbuffer.EndOfRowset)
                    _outputbuffer.SetEndOfRowset();

                ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "All inputs processed.", null, 0, ref cancel);
            }
            catch (Exception e)
            {
                bool fireAgain = false;
                ComponentMetaData.FireError(ComponentConstants.RUNTIME_GENERIC_ERROR, ComponentMetaData.Name, "An error has occurred: " + e.Message + ". \n" + e.StackTrace, null, 0, out fireAgain);
                return;
            }
        }

        /**
         * Executes the navigation+parsing operation for the given json, putting results into the buffer.
         */
        private void ProcessInMemory(StreamReader sr, RootType rootType, PipelineBuffer inputbuffer, PipelineBuffer outputbuffer)
        {
            bool fireAgain = false;
            using (sr)
            {
                bool cancel = false;
                ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Loading whole model into memory and deserializing...", null, 0, ref cancel);

                dynamic o = null;
                
                try
                {
                    // Load the whole json in memory.
                    using (var reader = new JsonTextReader(sr))
                    {
                        reader.DateParseHandling = _dateParsePolicy;
                        if (rootType == RootType.JsonObject)
                        {
                            o = JObject.Load(reader);
                            ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Object loaded.", null, 0, ref cancel);
                        }
                        else {
                            o = JArray.Load(reader);
                            ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Array loaded.", null, 0, ref cancel);
                        }
                    }

                    // Get all the tokens returned by the XPath string specified
                    if (_dataRootPath == null)
                        _dataRootPath = "";

                    // Navigate to the relative Root.
                    IEnumerable<JToken> els =  o.SelectTokens(_dataRootPath);
                    int rootEls = els.Count();
                    ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Array: loaded " + rootEls + " tokens.", null, 0, ref cancel);

                    // TODO Warning if no elements are found

                    int count = 0;
                    // For each root element we got...
                    foreach (JToken t in els) {
                        switch(t.Type) { 
                            case JTokenType.Array:
                                count+=ProcessArray(t as JArray, inputbuffer);
                                break;
                            case JTokenType.Object:
                                count+=ProcessObject(t as JObject, inputbuffer);
                                break;
                            default:
                                ComponentMetaData.FireError(ComponentConstants.RUNTIME_GENERIC_ERROR, ComponentMetaData.Name, "One of the values provided to ProcessArray wasn't either an array or an object (it probably was a bare integer/string). This usually happens when you are trying to parse an object while you got a primitive value instead. This operation is not yet supported.", null, 0, out fireAgain);
                                throw new Exception("One of the values provided to ProcessArray wasn't either an array or an object (it probably was a bare integer/string). This usually happens when you are trying to parse an object while you got a primitive value instead. This operation is not yet supported.");
                        }
                    }
                    ComponentMetaData.FireInformation(1000, ComponentMetaData.Name, "Succesfully parsed " + count + " tokens.", null, 0, ref cancel);
                }
                catch (Exception ex)
                {
                    ComponentMetaData.FireError(ComponentConstants.RUNTIME_ERROR_MODEL_INVALID, ComponentMetaData.Name, ex.Message + ex.StackTrace + ex.InnerException, null, 0, out cancel);
                    throw new Exception("Error occurred: " + ex.Message + ex.StackTrace + ex.InnerException);
                }
            }

        }

        public override IDTSExternalMetadataColumn100 InsertExternalMetadataColumnAt(int iID, int iExternalMetadataColumnIndex, string strName, string strDescription)
        {
            return base.InsertExternalMetadataColumnAt(iID, iExternalMetadataColumnIndex, strName, strDescription);
        }

        public override IDTSExternalMetadataColumn100 MapInputColumn(int iInputID, int iInputColumnID, int iExternalMetadataColumnID)
        {
            return base.MapInputColumn(iInputID, iInputColumnID, iExternalMetadataColumnID);
        }

        public override IDTSOutput100 InsertOutput(DTSInsertPlacement insertPlacement, int outputID)
        {
            throw new Exception("This component doesn't support any additional output");
        }

        public override IDTSInput100 InsertInput(DTSInsertPlacement insertPlacement, int inputID)
        {
            throw new Exception("This component doesn't support any additional input");
        }

        public override void DeleteInput(int inputID)
        {
            throw new Exception("You cannot delete the input lane");
        }

        public override void DeleteOutput(int outputID)
        {
            throw new Exception("You cannot delete the output lane");
        }

    }

    enum OperationMode {
        TRANSFORM,
        SOURCE
    }

